PART1: The Narratives / Chapter 1 Layering
================================================================================

* レイヤに関して考えるとき、以下のようなソフトウェアについて想像することができる:
    * 主要なサブシステムはいくつかのレイヤによって構成されている
    * それぞれのレイヤは、そのレイヤよりも低いレイヤの上に載っている
    * 低レイヤは高レイヤのことはわかっていない
    * レイヤは、その高レイヤから低レイヤを隠している


* レイヤ化することで以下のような利点がある:
    * 1つのレイヤを整合性の取れた集合とみなすことができる。他のレイヤについて知る必要はない。
        * イーサネットの動作の詳細を知らなくても、 TCP の上に FTP サーバを作ることができる
    * レイヤを別の実装に変更することができる
        * FTP サービスはイーサネットや PPP などの変更と関係なく稼働させることができる
    * レイヤ間の依存を最小化することができる
    * レイヤは標準化するのによい場所である
    * 1度あるレイヤを作ると、そのレイヤより上位のレベルのたくさんのサービスを作ることができる
        * TCP/IP は FTP, telnet, SSH, HTTP に使われている。そうででなければ、これらの高レベルのプロトコルはそれら自身の低レベルのプロトコルを書く必要がある


* レイヤ化は重要なテクニックだが、欠点もある:
    * レイヤはいくつかのことをカプセル化するが、それはすべてではない。結果として、一連の変更を行わなければいけない場合もある
        * 例として、あるフィールドを追加するとき、それは画面の UI やDB などすべてのレイヤに変更が必要な場合がある
    * 余分なレイヤは性能劣化につながる
        * すべてのレイヤの扱うものは、ある表現から別の表現に変更される必要がある。
        しかしながら、根本的な機能のカプセル化はしばしば欠点を補ってあまりある効率を与えてくれる。
        トランザクションを操作するレイヤは、最適化でき、すべてを速くするだろう

* layered architecture の最も難しい点は、「どのレイヤがが何をすべきか」と「各レイヤの責務が何か」を決めることである


--------------------------------------------------------------------------------

## エンタープライズアプリケーションにおけるレイヤの進化

* レイヤの考え方は 90 年代の client-server system から明らかになってきた
    * client は UI やその他のアプリケーションのコード
        * VB, Powerbuilder, Delphi
    * server は通常 RDB を指す
    * この作りはデータ集約型のアプリケーションを作ることを簡単にした。
      UIウィジェットは SQL を知っていた。そのため画面の要素とDB操作を接続することができた
* 一方で stored procedure にドメインロジックを保存する手法もあった。 ※ 諸説あり
  しかしこの方法はベンダーロックインされてしまうため、選択肢からは外された

* client-server システムが人気になってきたと同時に、オブジェクト指向の世界が盛り上がってきた。
* オブジェクト指向コミュニティはドメインロジックの問題に1つの答えをもたらした。
    3つのレイヤのシステムである:
  * UIのためのプレゼンテーション層
  * ドメインロジックのためのドメイン層
  * データソース
* この方法で複雑なドメインロジックは UI
    から切り離され、適切に構造化されたオブジェクトのあるレイヤに実装された

* Web の出現により、開発者は client-server アプリケーションを Web
    ブラウザにデプロイしたがっていた。よく設計された 3 layer system
    は新しいプレゼンテーション層を追加するだけでよかった。さらに、
    Javaによりオブジェクト指向言語がメインストリームとなった。

* layer と tier についての混乱が起こっているが、 多くの人は tier
    は物理的に分かれていることと解釈する。著者が強調するのは、
    layer は異なるマシン上で稼働させる必要はないということだ

## 3つのレイヤ

* プレゼンテーション
    * サービスの供給、情報の表示
        * HTMLのウィンドウ、マウスクリックなどリクエストの処理、HTTPリクエストの処理、
          コマンドラインの実行、バッチAPI
    * 責務は、「ユーザに情報を表示すること」「ユーザからのコマンドをドメインとデータソースに対するアクションに翻訳すること」
* ドメイン
    * システムの要になるロジック
    * 計算、バリデーション、プレゼンテーション層からのコマンドによるデータソースロジックの dispatch
* データソース
    * DBとのコミュニケーション、メッセージングシステム、トランザクションマネージャ、その他のパッケージ
    * 責務は、「永続データを保存すること」


* ドメイン層がデータソース層を隠す場合もあるが、
  プレゼンテーション層がデータソース層に直接アクセスし、表示する前にドメインロジックに操作をさせるという手法もある。


* プレゼンテーションは、開発者のつくるサービスが誰かに提供する外部インターフェースである
* データソースは、サービスを開発者に提供するものである

* どのようにレイヤを分けるかは、作るアプリケーションの複雑さによって変わってくる
    * 著者のアドバイスは、問題に対する最も適切な切り分けをすべきで、少なくともサブルーチンレベルで何かしらの切り分けをしている自覚を持つこと

* ドメインとデータソースはプレゼンテーションに依存すべきではない。このルールは、異なるプレゼンテーションを同じ基盤の上で置き換えることを簡単にするし、プレゼンテーションを重要な影響なしに修正することも簡単にする

* ドメインロジックを発見するのは難しい場合があるが、発見するよい方法がある
    * 根本的に異なるレイヤをアプリケーションに追加する場合、例えばコマンドラインインターフェースを Web アプリケーションに追加する場合を考える。
      このとき、何かしらの機能を重複させなければならなくなったら、それはドメインロジックがプレゼンテーションに染み出しているということ。
      relational DB と XML ファイルを置き換える場合に、ロジックを重複させる必要があるだろうか？


## レイヤを動かす場所を選ぶ

* 著者はこれまで論理的なレイヤについて述べてきたが、物理的なシステム構成が違いを生む
* IS アプリケーションで処理をクライアントか、デスクトップマシンか、サーバで動かすかという選択がある
    * ※ IS が何の略かわからなかった…
* サーバにすべての処理を寄せるとデプロイやアップグレードが簡単になる
* ただし、反応速度や失敗時の処理を考慮するとレイヤの処理を重複してクライアントとサーバに持つ選択肢も考えられる
    * ドメインロジックをすべてサーバに寄せるのがもっともメンテナンスしやすい
    * しかし、反応や切断時のことを考慮してクライアントにもドメインロジックを分ける需要もある
    * デスクトップとサーバにロジックを分けるのは最悪に聞こえるかもしれない。このようにする理由は、クライアントで動作させるドメインロジックが少ししかないからである。また、このロジックは他のシステムに依存せず分断されているべきである


* 絶対に必要にならない限りはレイヤを別々のプロセスに分けようとしてはいけない。性能を損ね複雑さを加えることになる
    * Remote Facades, Data Transfer Objects のようにすべき
* 分散、マルチスレッディング、 paradign chasms （object/relation
    のような）、マルチプラットフォーム開発、極度の性能要件は complexity boosters
    である
    * 必要な場合もあるが、開発とメンテナンスにコストがかかることを忘れてはならない
